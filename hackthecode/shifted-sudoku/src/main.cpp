/*
PROBLEM : 
I will give you a problem to solve in C++ languange, you have to deeply think and solve it with the least time complexity you can think. THE EXAMPLE TEST CASE IS WRONG!!! but i have a test case that is correct but i dont know the answer

The test case (unknown answer) :

6
9 2
X X 4 1 3 X X 5 8
3 5 X 9 X 7 X 4 6
3 7 5 X 6 X X 8 7
4 4 3 7 6 2 X 9 X
X 3 2 8 9 4 6 7 3
6 6 9 3 1 5 4 X 2
2 2 7 6 8 3 5 1 X
9 1 X 2 7 1 X 6 X
X 1 1 5 4 9 X 2 7
9 3
1 X 3 6 8 9 6 X 2
2 6 5 4 X 7 X 6 8
3 5 2 X 1 6 4 8 4
X 4 8 9 7 X 2 4 5
9 X 2 5 X 8 X 3 X
3 5 X 2 6 4 5 9 1
X X 9 1 2 6 9 2 X
4 3 1 X 9 5 8 7 X
5 2 X 7 4 3 3 X X
9 3
1 X 6 5 4 9 3 X 5
5 X X 4 X X 2 7 2
4 9 8 X X 7 3 6 3
X 8 X 7 6 X 9 3 X
X X 2 3 4 1 7 X 3
7 X 4 X 9 5 6 1 7
6 7 X X 2 8 4 5 X
2 X X 6 X 4 8 9 1
X 2 6 8 X 9 5 7 4
16 3
15 X X 7 13 8 1 9 11 12 X 5 3 14 4 X
13 3 11 10 12 7 10 5 9 4 15 6 1 8 16 2
8 1 4 14 6 15 16 X 7 X X X 12 10 9 11
6 X 16 5 4 11 2 14 8 3 1 10 13 7 5 15
2 X 13 9 3 4 12 8 1 15 7 16 X 9 14 5
X 4 15 11 X 1 9 6 13 X 10 12 7 2 8 3
6 2 9 4 1 11 13 10 8 12 16 7 5 15 16 14
14 9 7 3 11 10 13 2 3 8 5 4 16 X 6 12
9 16 X 1 5 13 11 4 6 1 3 X 8 12 2 14
1 5 6 15 15 12 8 7 10 14 11 2 9 16 X 4
12 11 3 X 16 2 X 1 15 5 X 8 6 13 10 7
7 2 14 4 9 3 6 10 4 16 12 13 11 5 X 1
12 8 X 8 1 2 10 16 7 13 5 9 4 X 15 6
16 15 5 14 8 9 4 11 12 13 14 1 2 3 X 10
3 10 9 6 X 6 5 15 2 7 8 11 14 4 13 16
4 13 8 X X 14 3 12 X 10 6 X 5 11 1 9
16 4
9 15 3 12 X X 4 11 16 10 X X 1 15 12 12
11 5 2 10 15 1 X 7 X 13 X X 16 12 5 7
6 8 16 13 9 14 10 12 4 X 2 15 3 9 9 2
X 1 7 4 16 X 13 3 5 12 6 11 15 11 4 9
1 3 8 16 2 6 5 X X X 15 9 10 8 15 16
4 13 9 11 12 16 3 8 6 2 5 10 14 14 11 4
5 12 14 6 10 9 7 15 X 4 X 3 8 2 3 10
2 10 15 X 11 13 1 4 8 14 16 X 6 X 10 1
3 X 13 5 6 4 12 1 2 8 7 14 11 7 X 3
10 11 1 X 14 15 X 5 12 3 13 16 2 10 8 10
2 X X 9 X 6 13 3 14 5 X 4 12 13 X 13
X 14 X 2 3 7 11 13 15 5 10 4 X 1 6 15
15 7 10 1 X X 16 2 14 11 8 13 12 16 16 6
8 2 X 9 13 X 14 X 7 15 12 1 4 5 2 14
12 6 4 14 1 11 15 10 3 16 9 5 7 15 1 11
13 16 11 X 7 12 8 X X 6 X 2 5 6 13 8
16 4
X 4 12 5 15 X 1 9 10 11 14 8 16 X 13 6
11 9 2 1 8 6 8 14 5 16 13 12 10 7 15 3
5 10 X X 16 11 12 7 15 2 4 1 X 12 14 6
12 X 9 6 7 X 2 X 1 11 5 15 X 14 16 X
2 15 X X 11 X 6 6 1 5 7 X 12 X 13 8
X 6 3 11 7 8 9 X 14 15 X 13 1 X 9 10
4 8 X X 1 13 11 12 2 3 16 10 15 5 6 11
12 5 1 13 X 2 3 3 11 8 6 9 7 14 4 16
7 16 9 15 13 3 X 10 8 4 5 6 14 11 12 2
X 11 5 X X X 13 X 3 12 9 16 6 13 8 X
14 1 12 4 X 16 8 2 X 11 10 15 3 X 5 7
13 X 6 8 9 5 16 11 X 1 X 2 16 4 X 15
1 9 8 4 16 6 3 7 5 5 12 X 15 11 13 10
3 14 13 7 X 1 X 8 10 9 2 X X 15 16 4
1 X 11 5 15 10 15 X 4 13 8 3 X 6 7 14
9 2 15 10 X 4 1 13 X X X X 5 8 3 12

Problem : 

Shifted Sudoku
The Reply Code Masters Team
12 March 2025
1. Problem statement
Everyone loves sudoku! Sudoku is more than just a game; it is a mental workout,
a test of logic, and a battle of wits against the grid. This number-based puzzle
has captivated millions of enthusiasts around the world. While sudoku gained
global fame in Japan, its origins go back much further. Inspired by 18th-century
mathematical concepts, it evolved into the modern form we know today thanks
to an American puzzle enthusiast. However, it was in Japan that the game truly
took off, earning its now-iconic name and becoming a staple in newspapers,
apps, and competitions.
The rules are simple: you are given an N×N square grid, where each cell either
contains a number from 1 to N or is empty. Your task is to fill all the empty cells with numbers from 1 to N, ensuring that no number appears more
than once in the same row, column, or any of the N designated square regions
(https://en.wikipedia.org/wiki/Sudoku).
But that’s not all—it’s about more than just solving a sudoku! The sudoku you
are given is shifted, and you must recreate the original puzzle before solving it.
Shifting a sudoku means moving all the elements of a row (or column) to the
left or right (or upward or downward in the case of columns). Any cells that are
moved out of the grid are replaced in the same order at the opposite end of that
row or column.
As you can see, any cells of the shifted sudoku that exceed the grid boundaries
are replaced on the opposite side within the same row. In particular, the selected
column has been shifted downward by 3 cells, and the selected row has been
shifted to the right by 7 cells. You are provided with a shifted sudoku and the
1
TEEN EDITION
number of shifts that have been applied to it. Your task is to recreate the original
sudoku and provide its solution. If more than one solution exists, each of them
is acceptable.
Note: In an N×N sudoku, a shift to the right by M cells is equivalent to a shift
to the left by N–M cells. Therefore, for the purpose of this solution, consider
only rightward shifts for rows and downward shifts for columns.
Note: Each row or column can be shifted at most once per test case.
2. Input format
The input file is a regular ASCII text file. Each line of the input file ends with
a single \n character (UNIX-style). If a line contains multiple data values, each
value is separated by a single space character.
For each test case Ci
, you will be provided with:
A line with two space-separated integers N and S, representing respectively the size of the sudoku (the length of every row or column) and the
number of shifts applied.
N lines indicating the rows of the shifted sudoku. Each row contains integer numbers from 1 to N or the character X for an empty cell.
3. Output format
The output file must be a regular ASCII text file. Each line of the output file
must end with a single \n character (UNIX-style). The rows represent, for each
test case in ascending order, the following:
A string indicating the test case number in the format Case #Ci
: .
A character R or C indicating if the shift is applied to a row or a column
of the grid.
An integer between 0 and N − 1, representing the number of the shifted
column or row (starting from the top left of the grid).
An integer between 1 and N − 1, indicating the number of shifts applied
rightward to each cell of the shifted row (or downward for columns) of the
grid.
4. Constraints
Number of cases for each level: 4 ≤ Ci ≤ 10
Number of rows (or columns) of the grid: 2 ≤ N ≤ 36
Number of shifts: 1 ≤ S ≤ 6
2
TEEN EDITION
5. Example
5.1. Input file example
1
9 2
8 X X 7 X X 2 X X
2 X 7 5 X 8 6 4 X
6 7 4 3 2 X 7 X 8
4 3 8 9 X 3 5 7 1
3 9 9 2 X 7 8 6 X
7 5 X 4 8 X 9 3 2
5 2 3 6 9 4 X 2 7
1 X 6 8 7 2 3 5 9
8 6 9 6 2 X 3 5 X
For the case C1, players have a squared 9x9 grid with 2 shifts applied.
5.2. Output file example
Case #1: R 8 7
C 1 6
8 3 1 7 4 6 2 9 5
2 9 7 5 1 8 6 4 3
6 5 4 3 2 9 7 1 8
4 2 8 9 6 3 5 7 1
3 1 9 2 5 7 8 6 4
7 6 5 4 8 1 9 3 2
5 8 3 6 9 4 1 2 7
1 4 6 8 7 2 3 5 9
9 7 2 1 3 5 4 6 8
For the case C1, the solution is shifting the row number eight of the grid (starting
from 0) of 7 cells and the column number two (always starting from 0) of 6 cells.
6. CTF recall
There’s a rumor about an advanced encryption technique hidden within Sudoku
grids. Some say that the shifting pattern holds a secret key. Maybe that leaked
encryption detail from the CTF challenge could help decrypt it. Switch tabs
and investigate; it might unlock more than just numbers.
*/
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cmath>

class SudokuSolver {
public:
    SudokuSolver(const std::vector<std::vector<std::string>>& shiftedGrid, int shifts, char direction, int index);
    void reconstructGrid();
    bool solveSudoku();
    void printSolution();
    void clearGrid();

private:
    bool solve(int row, int col);
    bool isSafe(int row, int col, int num);

    std::vector<std::vector<std::string>> shiftedGrid;
    std::vector<std::vector<int>> originalGrid;
    int shifts;
    char direction;
    int index;
};

SudokuSolver::SudokuSolver(const std::vector<std::vector<std::string>>& shiftedGrid, int shifts, char direction, int index) {
    this->shiftedGrid = shiftedGrid;
    this->shifts = shifts;
    this->direction = direction;
    this->index = index;
    this->originalGrid = std::vector<std::vector<int>>(shiftedGrid.size(), std::vector<int>(shiftedGrid.size(), 0));
}

void SudokuSolver::reconstructGrid() {
    int N = shiftedGrid.size();
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (shiftedGrid[i][j] != "X") {
                if (direction == 'R') {
                    originalGrid[i][(j + shifts) % N] = std::stoi(shiftedGrid[i][j]);
                } else if (direction == 'C') {
                    originalGrid[(i + shifts) % N][j] = std::stoi(shiftedGrid[i][j]);
                }
            }
        }
    }
}

bool SudokuSolver::solveSudoku() {
    return solve(0, 0);
}

bool SudokuSolver::solve(int row, int col) {
    int N = originalGrid.size();
    if (row == N) return true;
    if (col == N) return solve(row + 1, 0);
    if (originalGrid[row][col] != 0) return solve(row, col + 1);

    for (int num = 1; num <= N; ++num) {
        if (isSafe(row, col, num)) {
            originalGrid[row][col] = num;
            if (solve(row, col + 1)) return true;
            originalGrid[row][col] = 0;
        }
    }
    return false;
}

bool SudokuSolver::isSafe(int row, int col, int num) {
    int N = originalGrid.size();
    int sqrtN = std::sqrt(N);
    for (int x = 0; x < N; ++x) {
        if (originalGrid[row][x] == num || originalGrid[x][col] == num || 
            originalGrid[row - row % sqrtN + x / sqrtN][col - col % sqrtN + x % sqrtN] == num) {
            return false;
        }
    }
    return true;
}

void SudokuSolver::printSolution() {
    for (const auto& row : originalGrid) {
        for (const auto& num : row) {
            std::cout << num << " ";
        }
        std::cout << std::endl;
    }
}

void SudokuSolver::clearGrid() {
    for (auto& row : originalGrid) {
        std::fill(row.begin(), row.end(), 0);
    }
}

int main() {
    int numCases;
    std::cin >> numCases;
    std::cin.ignore();

    for (int caseNum = 1; caseNum <= numCases; ++caseNum) {
        int N, S;
        std::cin >> N >> S;
        std::cin.ignore();

        std::vector<std::vector<std::string>> shiftedGrid(N, std::vector<std::string>(N));
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < N; ++j) {
                std::cin >> shiftedGrid[i][j];
            }
        }

        char direction;
        int index, shifts;
        std::cin >> direction >> index >> shifts;

        SudokuSolver solver(shiftedGrid, shifts, direction, index);
        solver.reconstructGrid();
        if (solver.solveSudoku()) {
            std::cout << "Case #" << caseNum << ": " << direction << " " << index << " " << shifts << std::endl;
            solver.printSolution();
        } else {
            std::cout << "No solution exists" << std::endl;
        }
        solver.clearGrid();
    }

    return 0;
}